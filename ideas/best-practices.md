When explaining a system, it's helpful to explain the history and evolution of the architecture and the decisions and the thinking at the time, rather than just explain the current state. Understanding how it evolved and decisions made along the way helps build intuition about what's important for the system and how it may continue to evolve.

UML modeling for data repre is good. For behavior classes is really hard to get right on first try.
    - not a BP, just a thought?

Sequence diagram is super underutilized. Get familiar with a seq diagraming tool so that you enjoy using it. I love plant UML. Use it to efficiently communicate ideas to coworkers. Use it to prove to yourself you fully understand your solution.

Pay attention to the "soft" in software. It means it's malleable. We can change it. Refactoring is okay and we shouldn't prematurely optimize to strive for 0 refactoring in the future. If you're programming like how a hardware engineer would build hardware, or civil/mechanical, then you're doing it wrong.

As an engineer, you need to train your brain to eagerly search the state space of a design and find the first possible way to break it. Kind of like TLA+.
